Обнаружение копий себя в локальной сети
    Разработать приложение, обнаруживающее копии себя в локальной сети с помощью обмена multicast UDP сообщениями. 
        Приложение должно отслеживать моменты появления и исчезновения других копий себя в локальной сети и при 
        изменениях выводить список IP адресов "живых" копий.

    Адрес multicast-группы необходимо передавать параметром в приложение. Приложение должно поддерживать работу 
        как в IPv4 так и в IPv6 сетях, выбирая протокол автоматически в зависимости от переданного адреса группы.

    как запускать:
        IPv4:
            в 1 терминале:
                gcc -o res multicast_discovery.c && ./res 239.255.255.254 5000
            во 2 терминале:
                gcc -o res multicast_discovery.c && ./res 239.255.255.254 5000
        IPv6:
            в 1 терминале:
                gcc -o res multicast_discovery.c && ./res ff12::1234 5000
            во 2 терминале:
                gcc -o res multicast_discovery.c && ./res ff12::1234 5000

    socket
        int socket (int domain, int type, int protocol)
            domain - cпецификация семейства адресов
            type - cпецификация типа для нового сокета
            protocol - Используемый протокол. 
                Возможные параметры параметра протокола относятся к указанному семейству адресов и типу сокета. 

        в моем случае:
            socket(AF_INET, SOCK_DGRAM, 0)
                AF_INET - cемейство адресов IPv4 
                SOCK_DGRAM - тот тип сокета использует протокол UDP для семейства адресов Интернета. Посылаем ДАТАГРАМЫ 
                0 - вызывающий объект не хочет указывать протокол, и поставщик услуг выберет протокол для использования

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-socket
        https://www.opennet.ru/docs/RUS/linux_base/node245.html
    
    setsockopt
        int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
            s - дескриптор сокета
            level - уровень на котором определяется параметр
            optname - параметр сокета, для которого задаем значение
            optval - указатель на буфер, в котором указано значение запрошенного параметра
            optlen - размер буфера

        в моем случае:
            setsockopt(sock_fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout))

        https://www.opennet.ru/man.shtml?topic=setsockopt&category=2&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-setsockopt

    struct sockaddr_in
        struct sockaddr_in {
            sa_family_t     sin_family;     /* AF_INET */
            in_port_t       sin_port;       /* Port number */
            struct in_addr  sin_addr;       /* IPv4 address */
        };

        Структура sockaddr_in описывает сокет для работы с протоколами IP. 
            Значение поля sin_family всегда равно AF_INET.
            Поле sin_port содержит номер порта который намерен занять процесс. 
                Если значение этого поля равно нулю, то операционная система сама выделит свободный номер порта для сокета. 
            Поле sin_addr типа структуры in_addr, содержит IP адрес к которому будет привязан сокет.
                Структура in_addr содержит поле s_addr. Этому полю можно присвоить 32х битное значение IP адреса. 

        https://www.opennet.ru/docs/RUS/socket/node4.html
        https://man7.org/linux/man-pages/man3/sockaddr.3type.html
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2def/ns-ws2def-sockaddr_in

    htons
        uint16_t htons(uint16_t hostshort);
        Функция htons() преобразует узловой порядок расположения байтов 
            положительного короткого целого hostshort в сетевой порядок расположения байтов.
        
        https://www.opennet.ru/man.shtml?topic=htons&category=3&russian=0

    bind
        int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
            sockfd - дескриптор, определяющий несвязанный сокет, ему мы функцией bind задаем адрес
            addr - указатель на структуру sockaddr локального адреса, назначаемого связанному сокету
            addrlen - длина (в байтах) значения, на которое указывает addr

        в моем случае:
            bind(sock, (struct sockaddr*)&bind_addr, sizeof(bind_addr))

        функция используется сервером для присваивания сокету имени. До выполнения функции bind (т.е. присваивания 
            какого-либо имени, вид которого зависит от адресного домена) сокет недоступен программам-клиентам.

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock/nf-winsock-bind
        https://www.opennet.ru/docs/RUS/linux_base/node246.html

    sendto
        ssize_t sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
            s - Дескриптор, определяющий сокет
            msg - Указатель на буфер, содержащий передаваемые данные.
            len - Длина (в байтах) данных, на которые указывает параметр buf.
            flags - Набор флагов, указывающих способ вызова.
            to - Необязательный указатель на структуру sockaddr, содержащую адрес целевого сокета.
            tolen - Размер (в байтах) адреса, на который указывает параметр to.

        в моем случае:
            int bytes_sent = sendto(sock_fd, MESSAGE, strlen(MESSAGE), 0, (struct sockaddr*)&dest4, sizeof(dest4));

        важно: параметр flags является битовой маской и может содержать такие флаги: 
            MSG_CONFIRM - Сообщает (на уровне связи), что процесс пересылки произошел: вы получаете успешный ответ с другой стороны.
            ...

        Функция sendto используется для записи исходящих данных в сокет. 

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-sendto
        https://www.opennet.ru/man.shtml?topic=sendto&category=2&russian=0
    
    recvfrom
        int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);
            s - Дескриптор, определяющий привязанный сокет.
            buf - Буфер для входящих данных.
            len - Длина (в байтах) буфера, на который указывает параметр buf .
            flags - Набор параметров, которые изменяют поведение вызова функции за пределами параметров, указанных для связанного сокета. 
            from - Необязательный указатель на буфер в структуре sockaddr , который будет содержать исходный адрес при возврате.
            fromlen - Необязательный указатель на размер (в байтах) буфера, на который указывает параметр from.

        в моем случае:
            int bytes_received = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr*)&src, &srclen);

        Системный вызовы recvfrom используются для получения сообщений из сокета. Возвращает длину сообщения при успешном завершении.
        Аргумент flags системного вызова recv формируется с помощью объединения логической операцией ИЛИ 
            одного или более нижеследующих значений:
            MSG_WAITALL - просит подождать, пока не придет полное запрошенное количество данных.
            ...

        https://www.opennet.ru/man.shtml?topic=recvfrom&category=2&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-recvfrom

    inet_pton
        int inet_pton(int af, const char *src, void *dst);
            af - cпецификация семейства адресов (как в socket())
            src - указатель на строку, завершающуюся значением NULL, которая содержит текстовое 
                представление IP-адреса для преобразования в двоичную форму.
            dst - указатель на буфер, в котором будет храниться двоичное представление IP адреса. 
                IP адрес возвращается в порядке байтов сети.
        
        в моем случае: 
            inet_pton(AF_INET, host, &dest4.sin_addr)
                AF_INET - cемейство адресов IPv4
                host - преобразуемый IP адрес
                &dest4.sin_addr - указатель на буфер, куда записать двоичное представление IP адреса

        преобразует строку символов src в сетевой адрес (типа af), затем копирует полученную структуру с адресом в dst.
        По понятному: преобразует IP адрес из человекочитаемого строкового формата в бинарный, понятный сетевым функциям.

        https://www.opennet.ru/man.shtml?topic=inet_pton&category=3&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton

    ?   Что такое IP и порт?
    -   IP - числовой идентификатор хоста в сети, работающей по протоколу IP. Должен быть уникален для любого устройства в сети.
        СПРАВКА:    хост - устройство, объединяющее сеть.
                    IP (межсетевой протокол) - обеспечивает передачу данных без гарантии доставки.
        Порт - идентификатор программы или процесса, которые обслуживают сетевые соединения на заданном IP-адресе

        Представьте, что у вас дома 2 компьютера и они подключены к одному роутеру. Для всего интернета IP адрес этих 
            компьютеров одинаковый (так как внешний IP, который виден в интернете есть только у роутера). 
            В этом случае, чтобы обратиться к конкретному компьютеру, нужен порт. Например, на роутере настроено, 
            что у одного из компьютеров открыт порт 8245. Роутер имеет IP 95.84.208.79. Тогда обратиться к этому 
            компьютеру можно так: 95.84.208.79:8245
            
            IP адрес — это номер квартиры друга.
            Порт — это комната, в которой живёт друг

            https://qna.habr.com/q/844233#:~:text=Айпи-адрес%20-%20это%20адрес%20конкретного,конкретном%20компьютере%20шлется%20запрос%2C%20т.
            про порты: https://www.ittelo.ru/news/chto-takoe-port-v-seti/?srsltid=AfmBOorp-2zA1Mnurqtuc70K-Lrz_JDda0OzRAAma_09TCCyp9eXcH9W

    int main(int argc, char *argv[])
        создаю сокет для работы с UDP только для ПРИЕМА UDP пакетов; 
            при этом семейтсво адресов определяется в зависимости от переданного IP адреса: 
                если в нем сепаратор точка, то это IPv4 версия и семейство адресов: AF_INET, а иначе это IPv6 версия и 
                семейство адресов: AF_INET6
            ! для отправки UDP ппакетов будет создаваться отдельный временный сокет в send_multicast_message()
        устанавливаю таймаут 1 секунду на операции приема
        включаю опцию SO_REUSEADDR чтобы переиспользовать порт сразу после его закрытия, игнорируя TIMEWAIT
        bind() связывает сокет с адресом и портом
            и в этом же блоке нужно присоединить сокет к группе мультикаста - это нужно так как без этого сокет 
                по умолчанию принимает только адресованные ему сообщения (уникаст), а нам нужен мультикаст чтобы 
                получать все те пакеты, которые получает члены группы мультикаста.
        основной цикл: отправка мультикаст сообщения и прием ответов в течение 1 секунды, затем вывод полученных копий.

    char **receive_multicast_messages(int sock, int *count)
        *count = 0 - сбрасываем счётчик найденных адресов
        char **list = NULL - пока нет ни одного IP так что список пуст
        buf - буфер для чтения UDP-пакетов по сокету
        src + srclen - структура и её длина для recvfrom, чтобы получить адрес отправителя (IPv4/IPv6)
        
        в бесконечном цикле пытаюсь принять UDP пакеты из группы мультикаста через сокет, записать в buf "alive".
        src - отправитель UDP пакета, который заполняется recfrom()-ом, из него могу определить версию IP адреса
            и опираясь на неё, преобразую src->sin_addr в строку и записываю в ipstr
        realloc()-ом расширяю массив list на +1 элемент
        strdup() выделяет память и копирует туда ipstr, теперь полученный указатель записываю в list[*count]
        возвращаю указатель на list - массив IP адресов, которые приняли UDP-пакет в группе мультикаста.


    void send_multicast_message(char *host, int port, int family)
        для отправки UDP пакетов создается отдельный временный сокет
        с помощью setsockopt() устанавливаю TTL для IPv4 или HOPS для IPv6 -
            сколько маршрутизаторов пройдет пакет (не уйдет дальне двух маршрутизаторов)
        sendto() отправляет пакет в группу мультикаста и его примут все участники группы
        close() закрывает временный сокет